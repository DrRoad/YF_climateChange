---
title: "Simple warming projections"
author: "Katy Gaythorpe"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes: 
- \usepackage{placeins}
output: 
  pdf_document:
    df_print: "kable"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, error = FALSE)
knitr::opts_chunk$set(
  fig.path = "images/",
  dpi = 300
)
```

# Introduction

This takes the simple fitting including the temperature suitability index in the glm. In this case, the temperature suitbilty index takes the form of Mordecai et al. with the parameters from that text. We fit to this, then calculate the probability of detection given the serology fitting. We then produce projections of the risk of yellow fever reports given a blanket 2 or 4 degree rise in temperature. The nonlinear relationship between temperature and suitability give us some varying results in tranmission intensity and thus burden.

# GLM predictions

First we look at the predictions from the fitted model and then add 2 or 4 degrees to the temperatures across the region.

```{r set_up}

library(maptools)
library(sp) 
library(shapefiles)
library(Hmisc)
library(fields)
library(dplyr)
library(EnvStats)
library(readr)
library(reshape)
library(abind)
library(mvtnorm)
library(RColorBrewer)
library(truncdist)
library(wesanderson)

#########################################################################################################
### SETTING THE WORKING DIRECTORY ###
#########################################################################################################

shpdir = paste0("../","shapefiles/gadm2/")

#########################################################################################################
### LOADING SHAPEFILES AND COUNTRIES ###
#########################################################################################################

#read shapefiles in
shp0 = readShapePoly(paste0(shpdir, "Africa_adm0.shp")) #if gadm2
shp1 = readShapePoly(paste0(shpdir, "Africa_adm1.shp"))

#adjust titles
shp1$adm0_adm1 = paste(shp1$ISO, shp1$ID_1, sep="_")
shp1 = shp1[order(shp1$adm0_adm1),]

#read countries in
Countries = read_csv(paste0("../Data/","Countries.csv"))
c34 = Countries$c34
country34 = Countries$country34

#########################################################################################################
### SOURCE FUNCTIONS ###
#########################################################################################################

R.utils::sourceDirectory("FUNCTIONS")

#########################################################################################################
### LOAD ENVIRONMENTAL DATA ###
#########################################################################################################

Env_Table_path = (paste0("../Data/","Environment/Africa_adm1_dat_2017.csv")) #this file is adapted by hand to have latest outbreaks

dat_full = read.csv(Env_Table_path, stringsAsFactors=F)

### TEMP SUITABILITY ###
dat_full = cbind(dat_full, temp_suitability_mordecai(dat_full[,"ERAday.mean"]))
names(dat_full)[ncol(dat_full)] = "temp_suitability"

envdat = launch_env_dat(dat_full,c34)
dat = envdat$dat

#########################################################################################################
### FIT GLM ###
#########################################################################################################
                                           
modelVec = "cas.or.out~log.surv.qual.adm0+adm05+lon+logpop+temp_suitability" 

object_glm = fit_glm(dat =envdat$dat, depi = envdat$depi, modelVec )   #fit_glm from Kevin's code, adapted to take models as input
names(object_glm)

beta0 = object_glm[[1]]
x = object_glm[[2]]
y = object_glm[[3]]

```

```{r import_glm}

setwd("GLM_MCMC_chain_20180822_hamlet")

temp = list.files(pattern="\\.csv$")

fi = file.info(temp)
temp = temp[fi$size>5000]

l=lapply(temp,read.csv)
for(i in 1:length(l)){l[[i]] = l[[i]][,-1]}

glm_mcmc_out=data.table::rbindlist( l )

glm_mcmc_out = glm_mcmc_out[1000:nrow(glm_mcmc_out),]

Est_beta =  apply(glm_mcmc_out[,1:19], 2, median)
```

```{r plot_glm}

par(mfrow=c(2,2), mar = c(3,3,1,0)+0.1)

### data ###
plot(shp0, xlim=c(-15,45),ylim=c(-20,35), main = "Location of YF reports")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="black",add=T)

pres= dat$adm0_adm1[dat$cas.or.out>0]
mm1<-match(shp1$adm0_adm1,pres)
mm1<-match(pres, shp1$adm0_adm1)


plot(shp1[mm1,],col="red", add=T)
plot(shp0,lwd=2, add=T)
plot(shp1,lwd=1, add=T)

##################################################################################
### model ###

glmpreds_tmp = fun_calcPred( Est_beta,x,type="response")

mybreaks = seq(0,1.0001,by=0.01)
mycols =  heat.colors(length(mybreaks)-1)
mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(glmpreds_tmp,mybreaks)
vcols=101-vcols

plot(shp0, xlim=c(-15,45),ylim=c(-20,35), main="as fitted")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="black",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, xlim=c(-15,45),ylim=c(-20,35), add=T)

##############################
##### simple addtitive warming +2

##################################################################################
### model ###
Env_Table_path = (paste0("../../Data/","Environment/Africa_adm1_dat_2017.csv")) #this file is adapted by hand to have latest outbreaks

dat_full = read.csv(Env_Table_path, stringsAsFactors=F)

### WARMING ###
dat_full[,"ERAday.mean"] = dat_full[,"ERAday.mean"]+2

### TEMP SUITABILITY ###
dat_full = cbind(dat_full, temp_suitability_mordecai(dat_full[,"ERAday.mean"]))
names(dat_full)[ncol(dat_full)] = "temp_suitability"

envdat = launch_env_dat(dat_full,c34)


object_glm = fit_glm(dat =envdat$dat, depi = envdat$depi, modelVec )   #fit_glm from Kevin's code, adapted to take models as input
names(object_glm)

beta0_add2 = object_glm[[1]]
x_add2 = object_glm[[2]]
y_add2 = object_glm[[3]]
##################################################################################

### model ###
glmpreds_tmp_add2 = fun_calcPred( Est_beta,x_add2,type="response")

mybreaks = seq(0,1.0001,by=0.01)
mycols =  heat.colors(length(mybreaks)-1)
mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(glmpreds_tmp_add2,mybreaks)
vcols=101-vcols

plot(shp0, xlim=c(-15,45),ylim=c(-20,35), main="warming +2")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="black",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, xlim=c(-15,45),ylim=c(-20,35), add=T)



##############################
##### simple addtitive warming +4

##################################################################################
### model ###
Env_Table_path = (paste0("../../Data/","Environment/Africa_adm1_dat_2017.csv")) #this file is adapted by hand to have latest outbreaks

dat_full = read.csv(Env_Table_path, stringsAsFactors=F)

### WARMING ###
dat_full[,"ERAday.mean"] = dat_full[,"ERAday.mean"]+4

### TEMP SUITABILITY ###
dat_full = cbind(dat_full, temp_suitability_mordecai(dat_full[,"ERAday.mean"]))
names(dat_full)[ncol(dat_full)] = "temp_suitability"

envdat = launch_env_dat(dat_full,c34)


object_glm = fit_glm(dat =envdat$dat, depi = envdat$depi, modelVec)   #fit_glm from Kevin's code, adapted to take models as input
names(object_glm)

beta0_add4 = object_glm[[1]]
x_add4 = object_glm[[2]]
y_add4 = object_glm[[3]]
##################################################################################

### model ###
glmpreds_tmp_add4 = fun_calcPred( Est_beta,x_add4,type="response")

mybreaks = seq(0,1.0001,by=0.01)
mycols =  heat.colors(length(mybreaks)-1)
mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(glmpreds_tmp_add4,mybreaks)
vcols=101-vcols

plot(shp0, xlim=c(-15,45),ylim=c(-20,35), main="warming +4")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="black",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, xlim=c(-15,45),ylim=c(-20,35), add=T)
#image.plot(legend.only=T,breaks=mybreaks,col=rev(mycols),zlim=c(0,1), horizontal = T)


```

# Calculate the probability of detection and thus extrapolate transmission intensity

```{r import_serology_fit}


setwd("Z:/MultiModelInference/multi_model_MCMC_chain_20180622")

#list all files and read
temp = list.files(pattern="\\.csv$")

fi = file.info(temp)
temp = temp[fi$size>5000]

l=lapply(temp,read.csv)
mcmc_out=data.table::rbindlist( l , fill=TRUE)

#thin
mcmc_out=mcmc_out[seq(1,nrow(mcmc_out),10),]

mcmc_out = mcmc_out[,-1]

```


```{r setup_fit}
#########################################################################################################
### SOURCE FUNCTIONS ###
#########################################################################################################

source("../MultiModelInference/FUNCTIONS/Functions_Foi_model_reestimation.R") 
source("../MultiModelInference/FUNCTIONS/Functions_R0_model_reestimation.R") 
source("../MultiModelInference/FUNCTIONS/MCMC_functions.R") 
source("../MultiModelInference/FUNCTIONS/ProductSpaceFunctions.R") 
source("../MultiModelInference/FUNCTIONS/ProductSpaceFunctions_Sero.R")

#########################################################################################################
### LOADING SEROLOGY DATA ###
#########################################################################################################

#read serology in
Serology = read_csv(paste0("../Data/","Serology/serology.csv"))
Serology = filter(Serology, country_zone != "TCD_zone2") #ignoring this because there are no samples

### turn off some entries
Serology = filter(Serology, country_zone != "CAF")

#extracting values as the file is read as a tibble
sero_studies =  unique(Serology$country_zone)                                      #serology locations                                                      

#minimum of sero survey age groups
study_years = pull( unique(Serology[,c("country_zone","year") ] )[ ,2] , year)     #years each survey occurred
no_sero_surveys = length(sero_studies)                                             #Number of sero surveys in database

no_age_groups = rep(0,no_sero_surveys)                                             #Number of age groups in each survey
for (surveyIndex in 1:no_sero_surveys){
  no_age_groups[surveyIndex] = nrow( filter(Serology, country_zone== sero_studies[surveyIndex]) ) 
}

vc_factor = pull(unique(Serology[,c("country_zone","vc_factor") ] )[ ,2], vc_factor)  #whether to account for vaccination in serology or not
t0_vac = pull(unique(Serology[,c("country_zone","t0_vac") ] )[ ,2]  , t0_vac)         #first incidence of vaccination, pulled from tibble
names(t0_vac)=pull(unique(Serology[,c("country_zone","t0_vac") ] )[ ,1]  , country_zone)

adm1s_tibble = unique(Serology[ , c("country_zone", "gadm2")])[ ,2]                   #shape file admin locations in tibble form
adm1s=list()
for (surveyIndex in 1:no_sero_surveys) {
  adm1s[surveyIndex] = strsplit(as.character(adm1s_tibble[surveyIndex,1]),",")
}

survey_dat=list()  
age_min=list() #sample size and number positive for each age in each survey
age_max =list()
for (surveyIndex in 1:no_sero_surveys) {
  survey_dat[[surveyIndex]] = filter(Serology, country_zone==sero_studies[surveyIndex])[,c("samples","positives")]
  age_min[[surveyIndex]] = t( pull(filter(Serology, country_zone==sero_studies[surveyIndex])[,c("age_min")], age_min) )
  age_max[[surveyIndex]] = t( pull(filter(Serology, country_zone==sero_studies[surveyIndex])[,c("age_max")], age_max) )
}

#########################################################################################################
### POPULATION AND VACCINATION DATA ###
#########################################################################################################
path = "../Data/"

#function to collect , get totals for each year and proportions in each year
all_res_pop_3d = get_pop_data_3d(path = path, c_country=c34, dat=dat)

pop1 = all_res_pop_3d$pop1                                            #population import
pop3d = all_res_pop_3d$pop3d                                      #populations in 3d array
P_tot_2d = all_res_pop_3d$P_tot_2d                                    #total populations for each adm and year
p_prop_3d = all_res_pop_3d$p_prop_3d                                    #proportions of population

#get names
dim_adm  = dimnames(pop3d)[[1]]
dim_year = as.numeric(dimnames(pop3d)[[2]])
dim_age  = dimnames(pop3d)[[3]]
dim_survey = sero_studies

#########################################################################################################
### VACCINATION DATA ###
#########################################################################################################

vaccdir = paste0("../Data/", "Vaccination/")
# latest_vaccine_csv = "vaccination_coverage_by_adm1_year_age_base_skew0_update_2016-10-16.csv"
latest_vaccine_csv = "Outputs/adm1_old/vaccination_coverage_by_adm1_year_age_base_skew0.csv"   #updated at end of 2017

vc2d = read.csv(paste0(vaccdir,latest_vaccine_csv),stringsAsFactors = F, h=T) #read in latest vaccine coverage estimates

names(vc2d)[names(vc2d)=="country"]= "adm0"                          #rename countries as adm0
names(vc2d)[names(vc2d)=="adm1"]= "adm0_adm1"                        #renames adm1 as adm0_adm1

# formally "repair_vc_data" from FOI model in Kevin's folder
for (colIndex in 3:ncol(vc2d)){                                      #before 1995, we have NA values for those aged >75
  vc2d[,colIndex] = ifelse(is.na(vc2d[,colIndex]), vc2d[,colIndex-1], vc2d[,colIndex])
}
# restrict to lines in dat
vc2d = vc2d[vc2d[,"adm0_adm1"] %in% dat[,"adm0_adm1"],]

# create 3d array of adm, year, age
vc3d = transform_into_vc3d(vc2d,  adm="adm1")

#########################################################################################################
### CALCULATE VACCINE INCIDENCE ###
#########################################################################################################
inc_v3d = calc_incidence_vac_general(vc3d)

#########################################################################################################
### CALCULATE t0_vac_Africa ###
#########################################################################################################
t0_vac_africa = calc_t0_vac_africa(vc3d)

#########################################################################################################
### CALCULATE population moments ###
#########################################################################################################
pop_moments_whole = calc_pop_moments(p_prop_3d, t0_vac_africa,dim_adm,dim_year,dim_age)
#remember the last year of the data is hard-coded into this function so as the data gets updated, this should be checked

#########################################################################################################
### AGGREGATE POPULATION AND VACCINATION DATA ###
#########################################################################################################

#aggregate
list_aggregate_pop_vc =Make_aggregate_pop_vc_3d(pop1=pop1, vc2d=vc2d, sero_studies=sero_studies, adm1s=adm1s)
pop_agg3d = list_aggregate_pop_vc$pop_agg3d
vc_agg3d = list_aggregate_pop_vc$vc_agg3d

#calculate aggregated incidence (same function as before)
inc_v3d_agg = calc_incidence_vac_general(vc_agg3d);dim(inc_v3d_agg)

#calculate aggregated moments (different fucntion before)
pop_moments_agg = calc_pop_moments_agg(pop_agg3d,t0_vac,dim_year,study_years); dim(pop_moments_agg)


#########################################################################################################
### CREATE R0 LOOKUP TABLE ###
#########################################################################################################

load(paste0("../MultiModelInference/","R0_lookup_table.Rdata") )

#########################################################################################################
### pop at survey ###
#########################################################################################################
#foi_const_surv = c(0,1e-6,0,0,0,0,rep(0,no_sero_surveys-6))
foi_const_surv = rep(0, no_sero_surveys)

list_pop_at_survey = create_pop_at_survey(pop_agg3d,dim_survey,dim_year)
p_at_survey = list_pop_at_survey$p_at_survey_3d
P_tot_survey = list_pop_at_survey$P_tot_survey_2d

```

```{r transmission}

t=create_pop30.agg_vc30.agg(pop1, vc2d)
vc30.agg = t$vc30.agg
pop30.agg= t$pop30.agg
pop.vc.moments =t$pop.vc.moments

source('Z:/MultiModelInference/FUNCTIONS/burden_functions.R')

ii= 2:20
varsin_nc=ii[-grep("adm0",colnames(x))] - 1 

mcmc_out_r = filter(mcmc_out, model_chain ==1)
mcmc_out_f = filter(mcmc_out, model_chain ==0)


adjusted_params = c(exp(median(mcmc_out_f[,1])), 
                        apply(glm_mcmc_out[,1:19], 2, median,na.rm = T), 
                        exp(apply(mcmc_out_f[,c(2:41)], 2, median,na.rm = T)),
                        exp(median(mcmc_out_f[,82])) )
names(adjusted_params)[c(1,length(adjusted_params))] = c("vac_eff", "vc_factor_CMRs")

Foi_runs = fun_calc_transmission_Africa(x, ii, adjusted_params, dat, adm1s, t0_vac_africa, sero_studies, dim_year,
                                        dim_age, p_prop_3d, P_tot_2d, inc_v3d, pop1, vc2d, varsin_nc, polydeg = 5,
                                        R0_lookup, model_type = "Foi")


mybreaks= seq(-3, 1.2, length.out=100)
mycols =  rev( colorRampPalette(brewer.pal(11, "PuOr") )(length(mybreaks)-1) )
mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(log10(Foi_runs*100),mybreaks)



plot(shp0, xlim=c(-15,45),ylim=c(-20,30))
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="grey70",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, lwd=2, add=T)

image.plot(legend.only=TRUE,breaks=mybreaks,col=mycols,zlim=c(0,1), horizontal = TRUE, 
                    axis.args = list(at = c(-3:1), labels =c( "0.001", "0.01", "0.1","1","10"), las =2),
                    legend.mar = 3.5)
  
```

```{r transmission_withwarming}

par(mfrow=c(1,2))

###########################################
#glm predictions
mypreds_nc_add2  = fun_calcPred(coefs = as.numeric(adjusted_params)[ii],newdata=x_add2,type="link",varsin=varsin_nc) #this should be link

p_detect =  fun_calc_pdetect_multi_both(x=x, 
                                        adm1s= adm1s, 
                                        params=adjusted_params, 
                                        dat, 
                                        t0_vac_africa, 
                                        sero_studies, 
                                        dim_year, 
                                        dim_age, 
                                        p_prop_3d,
                                        P_tot_2d, 
                                        inc_v3d, 
                                        pop_moments_whole, 
                                        varsin_nc,
                                        "Foi")

p_detect_link = mean(p_detect)

#calculating number of infections over the observation period for the whole region
Ninf_whole = exp( mypreds_nc_add2 - p_detect_link) 

# calculate transmission
out = create_pop30.agg_vc30.agg(pop1,vc2d)
pop_vc_moments = out$pop.vc.moments

z = -Ninf_whole
polydeg = 5

if(polydeg>0) for(i in 1:polydeg) {
  z = cbind(z,(-1)^(i+1)*pop_vc_moments[,i+1]/factorial(i-1))
}

transmission_whole = sapply(1:nrow(x), function(i) polyroot(z[i,]))
transmission_whole[abs(Arg(transmission_whole))<=1e-10] = Re(transmission_whole)[abs(Arg(transmission_whole))<=1e-10]
transmission_whole[abs(Arg(transmission_whole))>1e-10] = NA

dt = dim(transmission_whole)
transmission_whole = as.numeric(transmission_whole)
dim(transmission_whole) = dt
transmission_whole = apply(transmission_whole,2,min,na.rm=T)

Foi_runs_add2 = transmission_whole


###########################################

mybreaks= seq(-3, 1.2, length.out=100)
mycols =  rev( colorRampPalette(brewer.pal(11, "PuOr") )(length(mybreaks)-1) )
mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(log10(Foi_runs_add2*100),mybreaks)



plot(shp0, xlim=c(-15,45),ylim=c(-20,30), main= "warming +2")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="grey70",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, lwd=2, add=T)

image.plot(legend.only=TRUE,breaks=mybreaks,col=mycols,zlim=c(0,1), horizontal = TRUE, 
           axis.args = list(at = c(-3:1), labels =c( "0.001", "0.01", "0.1","1","10"), las =2),
           legend.mar = 3.5)


###########################################
#glm predictions
mypreds_nc_add4  = fun_calcPred(coefs = as.numeric(adjusted_params)[ii],newdata=x_add4,type="link",varsin=varsin_nc) #this should be link


#calculating number of infections over the observation period for the whole region
Ninf_whole = exp( mypreds_nc_add4 - p_detect_link) 

# calculate transmission
out = create_pop30.agg_vc30.agg(pop1,vc2d)
pop_vc_moments = out$pop.vc.moments

z = -Ninf_whole
polydeg = 5

if(polydeg>0) for(i in 1:polydeg) {
  z = cbind(z,(-1)^(i+1)*pop_vc_moments[,i+1]/factorial(i-1))
}

transmission_whole = sapply(1:nrow(x), function(i) polyroot(z[i,]))
transmission_whole[abs(Arg(transmission_whole))<=1e-10] = Re(transmission_whole)[abs(Arg(transmission_whole))<=1e-10]
transmission_whole[abs(Arg(transmission_whole))>1e-10] = NA

dt = dim(transmission_whole)
transmission_whole = as.numeric(transmission_whole)
dim(transmission_whole) = dt
transmission_whole = apply(transmission_whole,2,min,na.rm=T)

Foi_runs_add4 = transmission_whole


###########################################

mybreaks= seq(-3, 1.2, length.out=100)
mycols =  rev( colorRampPalette(brewer.pal(11, "PuOr") )(length(mybreaks)-1) )
mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(log10(Foi_runs_add4*100),mybreaks)



plot(shp0, xlim=c(-15,45),ylim=c(-20,30), main= "warming +4")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="grey70",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, lwd=2, add=T)

image.plot(legend.only=TRUE,breaks=mybreaks,col=mycols,zlim=c(0,1), horizontal = TRUE, 
           axis.args = list(at = c(-3:1), labels =c( "0.001", "0.01", "0.1","1","10"), las =2),
           legend.mar = 3.5)

  
```


# Compare transmission predictions

We may now compare the force of infection across the three scenarios. To do this we map the difference between the baseline scenario and eiher the +2 or the +4 scenarios.

```{r compare_transmission}

par(mfrow=c(1,2))

difference_add2 = (Foi_runs_add2 - Foi_runs)/Foi_runs *100
difference_add4 = (Foi_runs_add4 - Foi_runs)/Foi_runs *100


mybreaks= seq(-200,200, length.out=100)
mycols =  rev( colorRampPalette(brewer.pal(11, "BrBG") )(length(mybreaks)-1) )
mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(difference_add2,mybreaks)

plot(shp0, xlim=c(-15,45),ylim=c(-20,30), main= "% difference +2")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="grey70",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, lwd=2, add=T)

image.plot(legend.only=TRUE,breaks=mybreaks,col=mycols,zlim=c(0,1), horizontal = TRUE, 
           #axis.args = list(at = c(-3:1), labels =c( "0.001", "0.01", "0.1","1","10"), las =2),
           legend.mar = 3.5)
#############################################################################################


mm = match(shp1$adm0_adm1,dat$adm0_adm1)
vcols = findInterval(difference_add4,mybreaks)

plot(shp0, xlim=c(-15,45),ylim=c(-20,30), main= "% difference +4")
mm0 = match(shp0$ISO,c34) #
plot(shp0[is.na(mm0),],col="grey70",add=T) 
plot(shp1[!is.na(mm),],col=mycols[vcols], xlim=c(-15,45),ylim=c(-20,30) , lty=0, add=T)
plot(shp0, lwd=2, add=T)

image.plot(legend.only=TRUE,breaks=mybreaks,col=mycols,zlim=c(0,1), horizontal = TRUE, 
           #axis.args = list(at = c(-3:1), labels =c( "0.001", "0.01", "0.1","1","10"), las =2),
           legend.mar = 3.5)

  
```

# Burden in 2050

Our last step is to predict the burden on 2050 under the three scenarios. We assume vaccination campaigns are as GAVI has laid out and we look at country level.

```{r burden}

Foi_scenarios = rbind(Foi_runs, Foi_runs_add2, Foi_runs_add4)

#import coverage data for each scenario
coverage_df_prev = read.csv(paste0("../Data/Vaccination/Outputs/", 
                              "vaccination_coverage_country_year_", 
                              "preventive", ".csv"), 
                       stringsAsFactors = FALSE)

####

pop_all = read.csv("../Data/Population/201708/201710gavi-5_dds-201710_int_pop_both.csv", 
                   stringsAsFactors = FALSE)

## Patch it up with GAB and GNQ data
pop_patch_GAB_GNQ = read.csv(
  "../Data/Population/201708/201710gavi-5_dds-201710_int_pop_both_GAB_GNQ.csv", 
  stringsAsFactors = FALSE)

pop_all = rbind(pop_all, pop_patch_GAB_GNQ)

pop_all = filter(pop_all, year>1939)

##########################################

infections =  rep(NA, 3*34)
dim(infections) = c(3, 34)

param_country_vec = NULL

for (country_ind in 1: 34){
  
  
  #get coverage for that country
  coverage_country_prev = filter(coverage_df_prev, country_code == c34[country_ind])
  
  #population for that country
  pop_country = filter(pop_all, country_code == c34[country_ind])
  
  ### want to reshape into previous format ###
  pop_new = NULL
  for (y in max(pop_country$year) : min(pop_country$year)){
    tmp = c(y, filter(pop_country, year == y)$value)
    
    if(length(tmp)< 102) {tmp = c(tmp, rep(NA, 102-length(tmp)))}
    pop_new = rbind(pop_new, tmp)
  }
  colnames(pop_new) = c("year", 0:100)
  pop_new = pop_new[order(pop_new[,1]),]
  ############################################
    
    #get model type
    model_type = "Foi"
    
  for( index in 1:3){
    
    param = Foi_scenarios[index,]
    names(param) = dat$adm0_adm1
    
    #collect transmission param for that country
    param_country = param[ grep(c34[country_ind], names(param)) ]
    
    #average over country
    param_country_ave = mean( as.numeric(param_country) )
    
    year_end = 2050
    
    #calculate start conditions
    immunity_start = fun_immunityStart(model_type,
                                       transmission_param = param_country_ave,
                                       age_max = 100,
                                       pop = pop_new,
                                       old_coverage = coverage_country_prev,
                                       year_end)
    

    
    #calculate burden in year of interest
    
    out_prev = run_infections_unit(model_type,
                                 transmission_param = param_country_ave,
                                 years = year_end,
                                 age.max = 100,
                                 pop = pop_new,
                                 coverage = coverage_country_prev,      #this is a subset of pop_moments_whole for adm1s of interest
                                 immunityStart = immunity_start)
    
    
    infections[index, country_ind] = sum(out_prev$new.infections) 

    param_country_vec = rbind(param_country_vec , c(param_country_ave, model_type, c34[country_ind]))
  
  } 
}

infections_df = as.data.frame(infections) 
names(infections_df)  = c34
```

```{r infection_plot}

inf_df = cbind( melt(infections_df[1,]), melt(infections_df[2,])[,2], melt(infections_df[3,])[,2] )
names(inf_df) = c("variable", "baseline", "warming_2", "warming_4")

inf_df_df = melt(inf_df)
names(inf_df_df) = c("variable", "scenario", "value")

colours = wes_palette("Zissou1")

ggplot(inf_df_df, aes(x = variable, y = value, fill = scenario)) + 
  geom_col(  position = position_dodge()) + 
  theme( axis.text.x = element_text(angle = 90, hjust = 1)) + 
  scale_fill_manual(values = colours[c(1,3, 5)])+
  xlab("") + ylab("Number of infections")

```

```{r burden_plot}
P_severe = median( rbeta(1000,6.367309,44.60736) )

burden_df = inf_df_df
burden_df$value = burden_df$value * P_severe

colours = wes_palette("GrandBudapest1")

ggplot(burden_df, aes(x = variable, y = value, fill = scenario)) + 
  geom_col(  position = position_dodge()) + 
  theme( axis.text.x = element_text(angle = 90, hjust = 1)) + 
  scale_fill_manual(values = colours)+
  xlab("") + ylab("Burden")


```

# Ranking countries by burden

We rank each country by the expected burden under each scenario.

```{r burden_rank}


df_rank = data.frame( "baseline" = filter(burden_df, scenario == "baseline")$variable[order(filter(burden_df, scenario == "baseline")$value, decreasing = TRUE)],
                      "warming_2"= filter(burden_df, scenario == "warming_2")$variable[order(filter(burden_df, scenario == "warming_2")$value, decreasing = TRUE)],
                      "warming_4"= filter(burden_df, scenario == "warming_4")$variable[order(filter(burden_df, scenario == "warming_4")$value, decreasing = TRUE)])

df_rank
```

```{r rank_change}

df_value_change = data.frame("country" = unique(burden_df$variable),
                             "baseline" = filter(burden_df, scenario == "baseline")$value,
                             "warming_2" = filter(burden_df, scenario == "warming_2")$value,
                             "warming_4" = filter(burden_df, scenario == "warming_4")$value)


WestAfrica = c("SEN", "GMB", "MRT", "MLI", "BFA", "SLE", "NGA", "NER", "BEN", "TGO", "GHA", "CIV", "LBR", "GIN", "GNB")

df_value_change$we = ifelse(df_value_change$country %in% WestAfrica, "W", "E")

# ggplot(df_value_change) + geom_segment( aes(x = rep(1,34), y = log10(baseline), xend = rep(2,34), yend = log10(warming_2), colour = we), size=2) +
#   geom_segment( aes(x = rep(2,34), y = log10(warming_2), xend = rep(3,34), yend = log10(warming_4), colour = we), size =2)

df_vale_we = data.frame("Location" = c("West", "East and central"),
                        "baseline" = c(sum(filter(df_value_change, we=="W")$baseline), sum(filter(df_value_change, we=="E")$baseline) ),
                        "warming_2" = c(sum(filter(df_value_change, we=="W")$warming_2), sum(filter(df_value_change, we=="E")$warming_2) ),
                        "warming_4" = c(sum(filter(df_value_change, we=="W")$warming_4), sum(filter(df_value_change, we=="E")$warming_4) ))


ggplot(df_vale_we) + geom_segment( aes( x = as.factor(1), y = log10(baseline), xend = as.factor(2), yend = log10(warming_2), colour = Location), size = 1) +
                     geom_segment( aes( x = as.factor(2), y = log10(warming_2), xend = as.factor(3), yend = log10(warming_4), colour = Location), size =1) +
  scale_colour_manual( values = c("blue", "orange")) +
  labs(x = "", y = "Burden (log scale)") + 
  scale_x_discrete(breaks = c("1","2","3"),labels=c( "Baseline", "Warming +2", "Warming +4"))

```
